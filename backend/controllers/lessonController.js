import { validationResult } from "express-validator";
import db from "../models/index.js";
import fs from "fs"; // Import fs for potential file deletion on update/delete
import path from "path"; // Import path

const { Lesson, Module, Course } = db;

// Get all lessons for a module
export const getModuleLessons = async (req, res, next) => {
  try {
    const { moduleId } = req.params;

    // Check if module exists
    const module = await Module.findByPk(moduleId);
    if (!module) {
      return res.status(404).json({
        success: false,
        message: "Module not found",
      });
    }

    const lessons = await Lesson.findAll({
      where: { moduleId },
      order: [["position", "ASC"]],
    });

    res.status(200).json({
      success: true,
      count: lessons.length,
      data: lessons,
    });
  } catch (error) {
    next(error);
  }
};

// Get single lesson
export const getLesson = async (req, res, next) => {
  try {
    const { lessonId } = req.params;

    const lesson = await Lesson.findByPk(lessonId, {
      include: [
        {
          model: Module,
          include: [
            {
              model: Course,
            },
          ],
        },
      ],
    });

    if (!lesson) {
      return res.status(404).json({
        success: false,
        message: "Lesson not found",
      });
    }

    // Check if user is enrolled in the course or is instructor/admin
    const course = lesson.Module.Course;
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: "Not authorized to access this lesson",
      });
    }

    // Allow access for instructor, admin, or enrolled user - this would require enrollment check
    // For now, we'll just allow any authenticated user

    res.status(200).json({
      success: true,
      data: lesson,
    });
  } catch (error) {
    next(error);
  }
};

// Create new lesson
export const createLesson = async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      // If validation fails after upload, consider deleting uploaded files
      if (req.files && req.files.length > 0) {
        req.files.forEach((file) => {
          fs.unlink(file.path, (err) => {
            if (err)
              console.error(
                "Error deleting uploaded file after validation error:",
                err
              );
          });
        });
      }
      return res.status(400).json({ errors: errors.array() });
    }

    const { moduleId } = req.params;
    const { title, content, type, videoUrl, duration, position } = req.body;

    // Check if module exists
    const module = await Module.findByPk(moduleId, {
      include: [{ model: Course }],
    });

    if (!module) {
      return res.status(404).json({
        success: false,
        message: "Module not found",
      });
    }

    // Check if user is authorized to create lessons for this module
    if (
      module.Course.instructorId !== req.user.id &&
      req.user.role !== "admin"
    ) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to create lessons for this module",
      });
    }

    let attachmentsData = [];
    if (req.files && req.files.length > 0) {
      attachmentsData = req.files.map((file) => ({
        filename: file.filename, // The unique filename generated by multer
        originalname: file.originalname,
        mimetype: file.mimetype,
        size: file.size,
        path: `/uploads/lessons/${file.filename}`, // Store the relative path to serve later
      }));
    }

    // Get max position if not provided
    let lessonPosition = position;
    if (lessonPosition === undefined) {
      const maxPositionLesson = await Lesson.findOne({
        where: { moduleId },
        order: [["position", "DESC"]],
      });
      lessonPosition = maxPositionLesson ? maxPositionLesson.position + 1 : 0;
    }

    // Create lesson
    const lesson = await Lesson.create({
      moduleId,
      title,
      content,
      type: type || "text",
      videoUrl: type === "video" && videoUrl ? videoUrl : null,
      duration,
      position: lessonPosition,
      attachments: attachmentsData,
    });

    res.status(201).json({
      success: true,
      data: lesson,
    });
  } catch (error) {
    // If error occurs after files uploaded, attempt cleanup
    if (req.files && req.files.length > 0) {
      req.files.forEach((file) => {
        fs.unlink(file.path, (err) => {
          if (err)
            console.error(
              "Error deleting uploaded file after controller error:",
              err
            );
        });
      });
    }
    next(error);
  }
};

// Update lesson
export const updateLesson = async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      // Cleanup newly uploaded files if validation fails
      if (req.files && req.files.length > 0) {
        req.files.forEach((file) =>
          fs.unlink(file.path, (err) => {
            if (err)
              console.error(
                "Error deleting file on update validation error:",
                err
              );
          })
        );
      }
      return res.status(400).json({ errors: errors.array() });
    }

    const { lessonId } = req.params;
    const {
      title,
      content,
      type,
      videoUrl,
      duration,
      position,
      removedAttachments,
    } = req.body;

    let lesson = await Lesson.findByPk(lessonId, {
      include: [
        {
          model: Module,
          include: [{ model: Course }],
        },
      ],
    });

    if (!lesson) {
      // Cleanup newly uploaded files if lesson not found
      if (req.files && req.files.length > 0) {
        req.files.forEach((file) =>
          fs.unlink(file.path, (err) => {
            if (err)
              console.error("Error deleting file when lesson not found:", err);
          })
        );
      }
      return res
        .status(404)
        .json({ success: false, message: "Lesson not found" });
    }

    // Check if user is authorized to update this lesson
    if (
      lesson.Module.Course.instructorId !== req.user.id &&
      req.user.role !== "admin"
    ) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to update this lesson",
      });
    }

    let currentAttachments = lesson.attachments || [];
    const filesToRemove = removedAttachments
      ? JSON.parse(removedAttachments || "[]")
      : []; // Assume removedAttachments is a JSON string array of paths

    // Remove attachments marked for deletion
    const updatedAttachments = currentAttachments.filter((att) => {
      const shouldRemove = filesToRemove.includes(att.path);
      if (shouldRemove) {
        // Delete the actual file from the server
        const filePath = path.join(process.cwd(), att.path);
        fs.unlink(filePath, (err) => {
          if (err)
            console.error(`Error deleting attachment file ${filePath}:`, err);
        });
      }
      return !shouldRemove;
    });

    // Add new attachments from req.files
    if (req.files && req.files.length > 0) {
      const newAttachmentsData = req.files.map((file) => ({
        filename: file.filename,
        originalname: file.originalname,
        mimetype: file.mimetype,
        size: file.size,
        path: `/uploads/lessons/${file.filename}`,
      }));
      updatedAttachments.push(...newAttachmentsData);
    }

    // Update lesson
    const updatedLessonData = {
      title: title || lesson.title,
      content: content !== undefined ? content : lesson.content,
      type: type || lesson.type,
      videoUrl: videoUrl !== undefined ? videoUrl : lesson.videoUrl,
      duration: duration !== undefined ? duration : lesson.duration,
      position: position !== undefined ? position : lesson.position,
      attachments: updatedAttachments, // Save the merged list
    };
    // Ensure videoUrl is null if type is not video
    if (updatedLessonData.type !== "video") {
      updatedLessonData.videoUrl = null;
    }

    lesson = await lesson.update(updatedLessonData);

    res.status(200).json({
      success: true,
      data: lesson,
    });
  } catch (error) {
    // Cleanup newly uploaded files if controller errors out
    if (req.files && req.files.length > 0) {
      req.files.forEach((file) =>
        fs.unlink(file.path, (err) => {
          if (err)
            console.error(
              "Error deleting file on update controller error:",
              err
            );
        })
      );
    }
    next(error);
  }
};

// Delete lesson
export const deleteLesson = async (req, res, next) => {
  try {
    const { lessonId } = req.params;

    const lesson = await Lesson.findByPk(lessonId, {
      include: [
        {
          model: Module,
          include: [{ model: Course }],
        },
      ],
    });

    if (!lesson) {
      return res.status(404).json({
        success: false,
        message: "Lesson not found",
      });
    }

    // Check if user is authorized to delete this lesson
    if (
      lesson.Module.Course.instructorId !== req.user.id &&
      req.user.role !== "admin"
    ) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to delete this lesson",
      });
    }

    // Delete associated attachment files before deleting the lesson record
    if (lesson.attachments && lesson.attachments.length > 0) {
      lesson.attachments.forEach(att => {
        const filePath = path.join(process.cwd(), att.path);
         fs.unlink(filePath, (err) => {
          if (err) console.error(`Error deleting attachment file ${filePath} during lesson deletion:`, err);
        });
      });
    }

    await lesson.destroy();

    res.status(200).json({
      success: true,
      message: "Lesson deleted successfully",
    });
  } catch (error) {
    next(error);
  }
};
